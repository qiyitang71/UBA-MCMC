# Artifact for Paper 151

This artifact provides the source code for our tool, [UBA-MCMC](https://github.com/qiyitang71/UBA-MCMC), which performs model checking of Markov chains against unambiguous Büchi automata (UBA) specifications.
UBA-MCMC is distributed under the GNU General Public License (GPL) v2.

## Load Docker Image

Ensure [Docker](https://www.docker.com/get-started/) is installed.
**Note:** Docker commands typically require **root** access.

Load the Docker image:

```bash
sudo docker load < uba-mcmc.tar.gz
# or
sudo docker load -i uba-mcmc.tar.gz
```

Check the image has been loaded:

```bash
sudo docker images
```
You should see `uba-mcmc` in the image list.

Run the container:

```bash
sudo docker run -it uba-mcmc
```

After the container starts, you should be placed in the default working directory:
```
/workspace
```

## Directory Structure

Inside this directory, you will find the following three key folders:

- `artifact` Contains all scripts needed to generate benchmarks and replicate the experimental results reported in our paper.

 
- `uba2pba` Contains the source code for converting an unambiguous Büchi automaton (UBA) into a probabilistic Büchi automaton, as described in our paper. This tool is built on top of [Spot library](https://spot.lre.epita.fr/).

- `prism` Contains the source code for our model checking tool, `prism-gfg`, which is built on top of [PRISM model checker](https://www.prismmodelchecker.org/). The core implementation of our model checking algorithm can be found in `prism/src/explicit/gfg`.

## Benchmarks

The random labelled Markov chain used to reproduce the results is:

```
./artifact/random_lmc.pm
```

The set of benchmarks (UBAs) are generated on the fly and stored in:

```
./artifact/UBAs/
```

### File Input Format

All automata are written in the [HOA format](https://adl.github.io/hoaf/).
An example automaton is shown below:

```hoa
HOA: v1
name: "FGa"
States: 4
Start: 0
AP: 1 "a"
acc-name: Buchi
Acceptance: 1 Inf(0)
properties: trans-labels explicit-labels state-acc complete unambiguous
properties: stutter-invariant
--BODY--
State: 0
[!0] 0
[0] 1
[0] 2
State: 1 {0}
[0] 1
[!0] 3
State: 2
[!0] 0
[0] 2
State: 3
[t] 3
--END--
```

## Installation

Our tool includes two components: automata transformation (`uba2pba`) and GfG model checking (`prism-gfg`).

Assume that we are inside `artifact` directory.

First, compile `uba2pba`:

```bash
cd uba2pba
make
```
After compilation, the executable file `uba2pba` should appear in the directory.

The tool `uba2pba` accepts an unambiguous Büchi automaton as input, determinises it using extra symbols and then minimises the deterministic automaton to a good-for-games (GfG) co-Büchi automaton. The GfG co-Büchi automaton is subsequently seen as a Büchi automaton. The nondeterminism in the resultant Büchi automaton can be resolved uniformly at randomly, so it is used as a probabilistic Büchi automaton (PBA) in our subsequent Markov chain model checking procedure.

Note that we write the probabilistic Büchi automaton to a file in the standard [HOA format](https://adl.github.io/hoaf/), omitting probabilities on transitions, as the nondeterminism can be resolved uniformly at random.

Then compile `prism-gfg`:

```bash
cd ../prism
make
```
**Note** During the compilation process, warning messages may appear, but the tool will still compile successfully. 

The executable file is `bin/prism`.

Our tool `prism-gfg` takes as inputs a Markov chain and the PBA produced by the tool `uba2pba`, and computes the probability that a word generated by the Markov chain belongs to the language recognised by the UBA (input of `uba2pba`).

## Smoke Tests

We compare our method with the state-of-the-art JCSS19 artifact ([link](https://wwwtcs.inf.tu-dresden.de/ALGI/TR/JCSS19/)).

Go to the `artifact` directory:

```bash
cd ../artifact
```

1. Test JCSS19:

```bash
./test_jcss19.sh
```

Expected output:

```
Generating UBA ...
UBA Model Checking uba-3 ...
Output: #states = 7, #product = 3779, time = 0.327 s
```

**Note** The running time can vary on different machines, the number of states in the UBA and the product should remain the same.

2. Test `uba2pba`:

```bash
./test_transformation.sh
```
This script converts the unambiguous Büchi automaton (UBA) specified in `UBAs/uba-3.hoa` to a PBA, and saves the result to `GFGs/gfg-3.hoa`.

3. Test GfG model checking:

```bash
./test_gfg.sh
```
This script performs model checking of the Markov chain defined in `random_lmc.pm` against the specification given by the PBA in `GFGs/gfg-3.hoa`. 

Expected output (time may vary):

```
Generating GfG automaton ...
GFG Model Checking gfg-3 ...
Output: #states = 5, #product = 3910, total_time = 1.182 s: 0 (trans), 1.182 (mc)
```

## Full Experiments

Assume that we are inside `artifact` directory.

To reproduce the full benchmark results:

```bash
./run.sh
```

This may take around **2 hours**. Results are saved in `./results`.

To print the results:

```bash
./print_data.sh
```

The results can be compared with **Table 1** in the paper. While timings may vary, the trend remains: from `n = 8`, our algorithm outperforms JCSS19.
Due to memory demands, JCSS19 may run out of resources before our method encounters issues.

To cross check results (the probabilities obtained by the two algorithms):
```bash
./cross_check.sh
```

This script compares the probabilities computed by the JCSS19 algorithm and our algorithm for values of `n` ranging from 3 to 12.
The results are expected to match for all values of `n` where both algorithms complete successfully. 

Example output:
```
Skipping n = 10, JCSS19 did not complete
Skipping n = 11, JCSS19 did not complete
Skipping n = 12, JCSS19 did not complete
All match!
```

To exit Docker:

```bash
exit
```

## Remove Docker Image

```bash
sudo docker rmi -f  uba-mcmc
```